# CS_350_Emerging_Systems_Architectures_and_Technology

### Summarize the project and what problem it was solving.
The two projects on this repository were geared at solving very different problems/tasks. The first (i.e., 5-1) was designed to flash a message in Morse code and change that message when a button was pressed on the microcontroller board. The second project (i.e., 7-1) was meant to simulate a thermostat by regularly measuring the temperature and turning on and off a heater based on a set point that was controllable by buttons on the device.

### What did you do particularly well?
I think one of the things I did particularly well was plan out the design of the state machines and task schedulers before doing any of the actual coding. These plans can be seen in both the PDFs uploaded to this repository. Going through the steps of preplanning before coding helped me to remain more focused while coding and ultimately helped to produce a better product more efficiently.

### Where could you improve?
The code for both projects (especially the project numbered 7-1) could have been more efficiently designed. I chose the design I did to showcase the standard way of programming a state machine as described in our textbook, but I believe it could have been streamlined a bit by removing some code that isn't strictly necessary. That being said, the way it is designed does increase its readability and maintainability but does so at the expense of system resource requirements so a balance must be struck in the final product should some cleanup be undertaken.

### What tools and/or resources are you adding to your support network?
The biggest thing I'll be adding to my toolbox is the concept of a state machine. The projects that were coded in this class could have been created in many different ways, but I believe that the state machine model is one that produced the cleanest possible product. Prior to this class, I would have attempted to building these projects in a much different manner that would have resulted in a much more convoluted and complex solution.

### What skills from this project will be particularly transferable to other projects and/or course work?
Again, the concept of a state machine will be very useful in other projects. To discuss another topic though, the ability to read through code from another library to determine how it is used an apply it to a new project will be very useful. Many of the header files used in this class had minimal documentation outside of the header files which required me to read through the in-file documentation instead of searching for tutorials or articles on the web for a solution. I am certain that I'll run into libraries like this in the future and being able to understand how to use it from its own documentation will be incredibly helpful.

### How did you make this project maintainable, readable, and adaptable?
I achieved this through three different aspects:
1. I gave names to things (i.e., variables, functions, etc.) that were logical and consistent.
2. I structured the code so that similar functions and variables were placed next to each other (as much as was possible).
3. I included many comments throughout the code to explain what a function did any how it performed the task it did.
